1.栈为受限制的线性表，只能通过端点来处理数据
2.为保持逻辑清晰和操作方便，规定：栈顶指针总是指在栈顶元素的下一个位置上


ADT Stack{
数据对象：
数据关系：
基本操作
InitStack(&s)//初始化或构造一个空栈

DestroyStack(&s)//销毁一个栈

ClearStack(&s)//清空栈为空栈

StackEmpty(s)//若栈为空，返回TRUE，否则返回FALSE

StackLength(s)//返回栈的长度

GetTop(s,&e)//返回栈顶元素，返回值赋值给e

Push(&s,e)//压栈
，
Pop(&s,&e)//出栈

StackTraverse(s,visit())//遍历栈，对栈内每个元素调用函数visit()
}ADT Stack

//链栈的结构说明
Typedef struct Snode{
	 ElemType data;
          struct Snode *next;
}Snode,*Slink;

Status push(Slink   L,ElemType x) {
       //不含头结点链栈的PUSH操作
      P=(SLink)malloc(sizeof(Snode)); //建新的结点
      P->data=x;
      P->next=L; // 链接到原来的栈顶
      L=P; 　// 移动栈顶指针
      return OK;  
} // PUSH
Status pop(Slink  L,ElemType &x) {
   //不含头结点链栈的pop操作
   if (!L) return ERROR;
    else {
             x=L->data; // 返回栈顶元素
	 p=L;
             L=L->next; // 修改栈顶指针 
             free(p); // 释放被删除的结点空间
    }
    return OK; 
 }
